---
layout: post
title: 'CSSE 120 Tangents: Abusing functions'
date: '2011-12-20T13:00:00.000-05:00'
author: David Bliss
tags:
- 120Tan
modified_time: '2012-01-05T11:20:58.517-05:00'
blogger_id: tag:blogger.com,1999:blog-7437262319199330260.post-683522770579483830
blogger_orig_url: http://blog.xenrelay.com/2011/12/csse-120-tangents-abusing-functions.html
comments: false
---

There are four things I want to introduce now: lambda functions, map, reduce, and partial functions. Before anything else, let me import some things quick:<br /><br /><pre>from functools import partial, reduce</pre><br />Lambda functions, in Python, are single-expression anonymous functions. Typically, they are used in only one expression. We can define an anonymous function like this:<br /><br /><pre class="brush: py;">lambda x, y, z=42: (x+y)&lt;z</pre><br />It is implied that the lambda function returns the single expression it is defined as. In this case, the lambda function returns a Boolean, indicating whether the sum of x and y is less than z, which defaults to 42 if it isn't given.<br /><br />Map is a function many languages have in some form. In all cases where it exists, map takes a function, and applies it to each item in an iterable in turn. A trivial example of map:<br /><br /><pre class="brush: py;">map(lambda x,y: 2*x+y, range(15), [2,3,48,3,89,2,54,3,7,5,6,1,5,45,2])</pre><br />Map is usually used with lambda functions, but map can be used with regular functions. Map can sometimes be replaced with list comprehensions. There is usually a fairly obvious reason to use one or the other. Sometimes list comprehensions are easier to comprehend, other times you might some feature unique to map.<br /><br />reduce, in the functools module, takes a function, a list of items, and applies a function (of two arguments) to each item in turn. To get the geometric mean of the numbers in a list lst, we could use:<br /><br /><pre class="brush: py;">geoMean = reduce(lambda x, y: x*y, lst)**(1/len(lst))</pre><br />Suppose we had two points, x and y, stored as lists. We want to know the distance between them, but don't know if they're one-, two-, or three-dimensions. Fortunately, we don't need to know:<br /><br /><pre class="brush: py;">diffs = 0<br />for i in range(len(x)):<br />    diffs += (x[i]-y[i])**2<br />dist = diffs**0.5<br /></pre>Not bad, but we can shorten that up a bit, can't we?<br /><br /><pre class="brush: py;">dist = sum(map(lambda a, b: (a-b)**2, x, y))**0.5</pre><br />The map(...) call produces a list of squares of differences, for each dimension. We then total this list of squared differences, and store the square root of the sum.<br /><br />Note that just because you can shorten your code, doesn't mean you should. There are a decent number of people that would prefer the four lines required for the for loop than the one line the sum(map(...)) uses. I will not preach one style or another, just point out the features and how they can be used.<br /><br />Now. Partial functions. Suppose we have a function that takes a bunch of arguments, and we almost always call it with the same argument set, or we need to pass that function to something, but with fewer arguments. We can use partial(...) from the functools module in order to accomplish this:<br /><br /><pre class="brush: py;">fromhex = partial(int, base=16)</pre><br />Let's create a module we can use to roll some dice used in role-playing games: <pre class="brush: py;">from random import randint<br />from functools import partial<br /><br />def dice(numDice, numSides):<br />    """Implements 1d6-like syntax"""<br />    return sum([randint(1,numSides) for i in range(numDice)])<br /><br />d4   = partial(dice, numSides=4)<br />d6   = partial(dice, numSides=6)<br />d8   = partial(dice, numSides=8)<br />d10  = partial(dice, numSides=10)<br />d12  = partial(dice, numSides=12)<br />d20  = partial(dice, numSides=20)<br />d100 = partial(dice, numSides=100)<br /><br />r1d4   = partial(dice, 1, 4)<br />r1d6   = partial(dice, 1, 6)<br />r1d8   = partial(dice, 1, 8)<br />r1d10  = partial(dice, 1, 10)<br />r1d12  = partial(dice, 1, 12)<br />r1d20  = partial(dice, 1, 20)<br />r1d100 = partial(dice, 1, 100)<br /></pre>partial is very situation-dependent, but it is useful to have for easy wrapper-function creation, or quickly creating an adapter function to mesh libraries together. As with all Python, there is such a thing as too much magic.
