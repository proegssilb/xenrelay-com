---
layout: post
title: 'CSSE 120 Tangents: Objects'
date: '2012-01-24T09:00:00.000-05:00'
author: David Bliss
tags:
- 120Tan
modified_time: '2012-01-24T09:00:13.380-05:00'
blogger_id: tag:blogger.com,1999:blog-7437262319199330260.post-2819032700374494077
blogger_orig_url: http://blog.xenrelay.com/2012/01/120-tangents-objects.html
---

If I was allowed to talk about anything I wanted, regardless of the CSSE curriculum, I would have talked about objects in my first post, simply because they are so critical to everything in Python. But, here we are.<br /><br />So far, we have seen functions and variables. Sometimes, the functions created temporary variables so they could store data. But, these are still mostly two different ideas. A block of stuff is either code or data, not both.<br /><br />Objects are a way to group data and functions, to create a cohesive thing that can vary in properties, and can do things. For example:<br /><br /><pre class="brush: py;">class JailCell(object):<br />    contents = ()<br />    door = None<br /><br />    def __init__(self, openDoor=False, material='Stone'):<br />        super(JailCell, self).__init__(self)<br />        self.contents = ()<br />        self.door = Door(mat=material, doorState=openDoor)<br />    def open(self):<br />        self.door.open = True<br /></pre>This jail cell can contain some stuff, and has an openable door made of different materials. Cool. Let's go over some stuff we see in this basic class:  <br /><ul><li>Class declarations always begin with the keyword class, a class name, and can have arguments.</li><li>Positional arguments given to a class declaration are interpreted as base classes. When python creates the class definition, it first populates the class with functions and variables from base classes, in the order specified. You can use this to have classes act as templates for each other.</li><li>self is the current object being operated on. If I have: <pre class="brush: py;">o = JailCell()<br />o.open()<br /></pre>Then the function open from class JailCell is called with self=o. Functionally identical code: <pre class="brush: py;">o = JailCell()<br />JailCell.open(o)<br /></pre></li><li>We can declare variables on the class level. This provides a default for new objects of this class (called <i>instances</i>), but it is preferred to explicitly assign all properties in __init__.</li><li>Python has a complex object creation process. Let's use the same segment as before: <pre class="brush: py;">o = JailCell()<br />o.open()<br /></pre>In the first line, a lot of magic happens. First, we call JailCell.__new__(JailCell) to get an object to work with. JailCell inherits from object, which implements a default __new__, so we're good there. Then, Python calls JailCell.__init__(o) to do further initialization. The call to super() is how python ensures that inheriting functions is done correctly.</li><li>Function definitions inside of a class are identical to function definitions outside of a class. However, they are declared in a different scope, making referring to them slightly different.</li><li>Python uses double-underscores for lots of internal stuffs. In the case of __functionName__, these are usually intended to be overridden for special functionality. cls.__add__ is used to override addition when the first object is of type cls. I'll introduce others in a future post, when I show a couple of data types. </li></ul>Now. Let's go back for a minute. I started off with saying that objects are critical to Python. Anyone remember the dir() function? It lists the attributes of an object. How about type()? It gives the type of an object. OK, let's try something: <br /><pre class="brush: python;">Python 3.2 (r32:88445, Feb 20 2011, 21:29:02) [MSC v.1500 32 bit (Intel)] on win<br />32<br />Type "help", "copyright", "credits" or "license" for more information.<br />&gt;&gt;&gt; class Foo():<br />...     pass<br />...<br />&gt;&gt;&gt; f = Foo()<br />&gt;&gt;&gt; f<br />&lt;__main__.Foo object at 0x015B0EB0&gt;<br />&gt;&gt;&gt; dir(f)<br />['__class__', '__delattr__', '__dict__', '__doc__', '__eq__', '__format__', '__g<br />e__', '__getattribute__', '__gt__', '__hash__', '__init__', '__le__', '__lt__',<br />'__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '_<br />_setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__']<br />&gt;&gt;&gt; type(f)<br />&lt;class '__main__.Foo'&gt;<br />&gt;&gt;&gt; type(f) is Foo<br />True<br />&gt;&gt;&gt; type(type(f))<br />&lt;class 'type'&gt;<br />&gt;&gt;&gt; type(type(f)) is type<br />True<br />&gt;&gt;&gt; dir(type)<br />['__abstractmethods__', '__base__', '__bases__', '__basicsize__', '__call__', '_<br />_class__', '__delattr__', '__dict__', '__dictoffset__', '__doc__', '__eq__', '__<br />flags__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__i<br />nit__', '__instancecheck__', '__itemsize__', '__le__', '__lt__', '__module__', '<br />__mro__', '__name__', '__ne__', '__new__', '__prepare__', '__reduce__', '__reduc<br />e_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasscheck__'<br />, '__subclasses__', '__subclasshook__', '__weakrefoffset__', 'mro']<br />&gt;&gt;&gt; dir(Foo)<br />['__class__', '__delattr__', '__dict__', '__doc__', '__eq__', '__format__', '__g<br />e__', '__getattribute__', '__gt__', '__hash__', '__init__', '__le__', '__lt__',<br />'__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '_<br />_setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__']<br /></pre><br /><pre class="brush: python;">&gt;&gt;&gt; Foo.__class__<br />&lt;class 'type'&gt;<br />&gt;&gt;&gt; type.__class__<br />&lt;class 'type'&gt;</pre><br />Look familiar? This is how Python knows what type of thing something is. But, type is its own type. Which confirms that type is a class. We can conclude that classes are instances of type, and therefore objects. Let's try something else quick: <br /><pre class="brush: python;">&gt;&gt;&gt; type(int)<br />&lt;class 'type'&gt;</pre><br />Not even the lowly int can escape Python's object system. By now, if you've been keeping up with everything, you should be becoming at least somewhat aware of an inescapable truth in Python:  <b> EVERYTHING IS AN OBJECT </b> Everything. Even functions are objects. Want to make a callable object? Create a class with a __call__ function, and create an instance. Done.
