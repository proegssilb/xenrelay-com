---
layout: post
title: 'CSSE 120 Tangents: Tour of a Python Script'
date: '2011-12-06T12:00:00.002-05:00'
author: David Bliss
tags:
- 120Tan
modified_time: '2011-12-19T12:35:10.904-05:00'
blogger_id: tag:blogger.com,1999:blog-7437262319199330260.post-170825418958312530
blogger_orig_url: http://blog.xenrelay.com/2011/12/tour-of-python-script.html
---

Python is a curious language, in that every single line tells the interpreter to do something. Other languages describe a construct with some commands, and to do things with other commands.<br /><br />For example, in Java, each file describes a class. At runtime, the class description is already loaded in memory, and doesn't need to be constructed. In Python, definitions are created at run-time, and there are various ways to tweak the results of the definitions. I may cover some of these tricks later.<br /><br />Remember that now. Python also evaluates its scripts one line at a time. So, if we create a simple script like <i>(Don't run this unless you know what it does)</i>:<br /><pre class="brush: py;">import sys, os<br /><br />os.rename(sys.argv[1], sys.argv[2])<br /></pre><br />At runtime, it would load the modules given by the import, possibly executing some Python contained in them, and then run the function call given. Other languages would create structures in the code run such that the modules were already there when the program needed them. Same principle applies to defining functions.<br /><br />In a week or two, I'll be able to showcase some fancier bits of code, but for now, I'm trying to avoid spoilers. Maybe some curious individuals out there can poke around os, os.path, and sys and discover a way to implement a command-line utility to copy a file to a new place?