---
layout: post
title: 'CSSE120 Tangents: The Infrastructure of Classes'
date: '2012-02-03T12:57:00.000-05:00'
author: David Bliss
tags:
- 120Tan
modified_time: '2012-02-03T23:00:12.306-05:00'
blogger_id: tag:blogger.com,1999:blog-7437262319199330260.post-6570148072684726943
blogger_orig_url: http://blog.xenrelay.com/2012/02/csse120-tangents-infrastructure-of.html
comments: false
---

Before we get started, I missed one important detail. There were multiple references to self, all of which were completely unexplained.<br /><br />In Python, self represents the current object being worked with. It is the first argument of all methods, but Python takes care of making the references work. Technically, it is possible to use a name other than self, but to do so will probably break some IDEs and enrage programmers.<br /><br />Moving on.<br /><br />By default, a given object cannot work with any operator (+, -, &gt;, ==, etc.) except 'is' (same-object, or same-reference). Objects wishing to define themselves as being comparable have to implement one set of functions, iterable has another set, and so on. Conversion to int, float, and string can also be defined.<br /><br />In order to get an attribute of an object, python first calls __getattribute__, which by default checks an object's __dict__, and then in the class's __dict__. If the name is defined in __dict__, it returns that value. Else, it calls __getattr__, which errors by default.<br /><br />That above logic applies to methods as much as instance variables. It just so happens that the value retrieved as a callable function.<br /><br />However, in true Python spirit, this can be changed. If a class defines __getattr__, it can pretend attributes exist, and define a behavior for those fake attributes. Additionally, the property() function can be used to define functions that get and/or set a virtual property. If a class defines __getattribute__, the same thing happens, but with all attributes resulting in a call to __getattribute__.<br /><br />Important methods for list-emulating types:<br /><ul><li>__getitem__(self, key): implements reading of subscripts. Interpretation of key is unspecified, should raise IndexError or KeyError, depending on whether you want to emulate a list or a dictionary (for loops expect KeyError).&nbsp;</li><li>__setitem__(self, key, value): implements subscript assignment. Interpretaion of key should be consistent with __getitem__, unless you want to be flamed&nbsp; by everyone.</li><li>__len__(self): Returns the number of items in the sequence or map.</li><li>__iter__(self): Implements iteration over the sequence. Using yield is recommended.</li><li>__reversed__(self): Implements reverse-order iteration.</li><li>__contains__(self, item): Implements efficient item membership testing. Optional.</li></ul>More methods for numeric types and other things exist, but this post is taking too long to write, so this is what I'm posting for now. <br /><ul></ul><br />
